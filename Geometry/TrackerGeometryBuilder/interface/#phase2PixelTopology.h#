#ifndef Geometry_TrackerGeometryBuilder_phase2PixelTopology_h
#define Geometry_TrackerGeometryBuilder_phase2PixelTopology_h

#include <cstdint>
#include <array>

namespace phase2PixelTopology {

  constexpr uint16_t numRowsInRoc = 80;
  constexpr uint16_t numColsInRoc = 52;
  constexpr uint16_t lastRowInRoc = numRowsInRoc - 1;
  constexpr uint16_t lastColInRoc = numColsInRoc - 1;

  constexpr uint16_t numRowsInModule = 2 * numRowsInRoc;
  constexpr uint16_t numColsInModule = 8 * numColsInRoc;
  constexpr uint16_t lastRowInModule = numRowsInModule - 1;
  constexpr uint16_t lastColInModule = numColsInModule - 1;

  constexpr int16_t xOffset = -81;
  constexpr int16_t yOffset = -54 * 4;

  constexpr uint32_t numPixsInModule = uint32_t(numRowsInModule) * uint32_t(numColsInModule);

  constexpr uint32_t numberOfModules = 3766;
  constexpr uint32_t numberOfLayers = 28;
  constexpr uint32_t layerStart[numberOfLayers + 1] = {0,108,324,504,

                                                       630, 738, 846, 954, 1062, 1170, 1278, 1386, 1494, 1670, 1846, 2022,
                                                       2198, 2306, 2414, 2522, 2630, 2738, 2846, 2954, 3062, 3238, 3414, 3590,

                                                       numberOfModules};

  constexpr char const* layerName[numberOfLayers] = {
    "BL1",
    "BL2",
    "BL3",
    "BL4",  // barrel
    "E-1", "E-2", "E-3", "E-4", "E-5", "E-6", "E-7", "E-8", "E-9", "E-10", "E-11", "E-12",
    "E+1","E+2","E+3","E+4","E+5","E+6","E+7","E+8","E+9","E+10","E+11","E+12"
  };

  constexpr uint32_t numberOfModulesInBarrel = 630;
  constexpr uint32_t numberOfLaddersInBarrel = 84;

  template <class Function, std::size_t... Indices>
    constexpr auto map_to_array_helper(Function f, std::index_sequence<Indices...>)
    -> std::array<typename std::result_of<Function(std::size_t)>::type, sizeof...(Indices)> {
    return {{f(Indices)...}};
  }

  template <int N, class Function>
    constexpr auto map_to_array(Function f) -> std::array<typename std::result_of<Function(std::size_t)>::type, N> {
    return map_to_array_helper(f, std::make_index_sequence<N>{});
  }

  constexpr uint32_t findMaxModuleStride() {
    bool go = true;
    int n = 2;
    while (go) {
      for (uint8_t i = 1; i < numberOfLayers + 1; ++i) {
        if (layerStart[i] % n != 0) {
          go = false;
          break;
        }
      }
      if (!go)
        break;
      n *= 2;
    }
    return n / 2;
  }

  constexpr uint32_t maxModuleStride = findMaxModuleStride();

  constexpr uint8_t findLayer(uint32_t detId) {
    for (uint8_t i = 0; i < numberOfLayers + 1; ++i)
      if (detId < layerStart[i + 1])
        return i;
    return numberOfLayers + 1;
  }

  constexpr uint8_t findLayerFromCompact(uint32_t detId) {
    detId *= maxModuleStride;
    for (uint8_t i = 0; i < numberOfLayers+1; ++i)
      if (detId < layerStart[i + 1])
        return i;
    return numberOfLayers + 1;
  }

  constexpr uint32_t layerIndexSize = numberOfModules / maxModuleStride;
  constexpr std::array<uint8_t, layerIndexSize> layer = map_to_array<layerIndexSize>(findLayerFromCompact);

  constexpr bool validateLayerIndex() {
    bool res = true;
    for (auto i = 0U; i < numberOfModules; ++i) {
      auto j = i / maxModuleStride;
      res &= (layer[j] < 10);
      res &= (i >= layerStart[layer[j]]);
      res &= (i < layerStart[layer[j] + 1]);
    }
    return res;
  }

  static_assert(validateLayerIndex(), "layer from detIndex algo is buggy");

  // this is for the ROC n<512 (upgrade 1024)
  constexpr inline uint16_t divu52(uint16_t n) {
    n = n >> 2;
    uint16_t q = (n >> 1) + (n >> 4);
    q = q + (q >> 4) + (q >> 5);
    q = q >> 3;
    uint16_t r = n - q * 13;
    return q + ((r + 3) >> 4);
  }

  constexpr inline bool isEdgeX(uint16_t px) { return (px == 0) | (px == lastRowInModule); }

  constexpr inline bool isEdgeY(uint16_t py) { return (py == 0) | (py == lastColInModule); }

  constexpr inline uint16_t toRocX(uint16_t px) { return (px < numRowsInRoc) ? px : px - numRowsInRoc; }

  constexpr inline uint16_t toRocY(uint16_t py) {
    auto roc = divu52(py);
    return py - 52 * roc;
  }

  constexpr inline bool isBigPixX(uint16_t px) { return (px == 79) | (px == 80); }

  constexpr inline bool isBigPixY(uint16_t py) {
    auto ly = toRocY(py);
    return (ly == 0) | (ly == lastColInRoc);
  }

  constexpr inline uint16_t localX(uint16_t px) {
    auto shift = 0;
    if (px > lastRowInRoc)
      shift += 1;
    if (px > numRowsInRoc)
      shift += 1;
    return px + shift;
  }

  constexpr inline uint16_t localY(uint16_t py) {
    auto roc = divu52(py);
    auto shift = 2 * roc;
    auto yInRoc = py - 52 * roc;
    if (yInRoc > 0)
      shift += 1;
    return py + shift;
  }

  //FIXME move it elsewhere?
  struct AverageGeometry {
    static constexpr auto numberOfLaddersInBarrel = phase1PixelTopology::numberOfLaddersInBarrel;
    float ladderZ[numberOfLaddersInBarrel];
    float ladderX[numberOfLaddersInBarrel];
    float ladderY[numberOfLaddersInBarrel];
    float ladderR[numberOfLaddersInBarrel];
    float ladderMinZ[numberOfLaddersInBarrel];
    float ladderMaxZ[numberOfLaddersInBarrel];
    float endCapZ[2];  // just for pos and neg Layer1
  };

}  // namespace phase1PixelTopology


#endif  // Geometry_TrackerGeometryBuilder_phase1PixelTopology_h

/*
  CONSTANT_VAR const uint8_t layerPairs[2 * nPairs] = {

      0, 1, 0, 4, 0, 7,              // BPIX1 (3)
      1, 2, 1, 4, 1, 7,              // BPIX2 (5)
      4, 5, 7, 8,                    // FPIX1 (8)
      2, 3, 2, 4, 2, 7, 5, 6, 8, 9,  // BPIX3 & FPIX2 (13)
      0, 2, 1, 3,                    // Jumping Barrel (15)
      0, 5, 0, 8,                    // Jumping Forward (BPIX1,FPIX2)
      4, 6, 7, 9                     // Jumping Forward (19)
  };



CONSTANT_VAR const int16_t phicuts[nPairs]{phi0p05, phi0p07, phi0p07,
					     phi0p05, phi0p06, phi0p06,

					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,

					     phi0p06, phi0p06, phi0p06,

					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05,
					     phi0p05, phi0p05

					     

#endif/*   // Geometry_TrackerGeometryBuilder_phase1PixelTopology_C-x C-sh */
/* */